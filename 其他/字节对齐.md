 先来看四个重要的基本概念：

​     1) 数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。（数据类型自身的对齐值）

​     2) 结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。（结构体或类的自身对齐值）

​     3) 指定对齐值：#pragma pack (value)时的指定对齐值value。（指定对齐值）

​     4) 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。 （数据成员，结构体和类的有效对齐值-较小者）



即：

- 数据类型自身的对齐值
- 结构体或类的自身对齐值
- 指定对齐值
- 数据成员，结构体和类的有效对齐值-较小者



​     其中，有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”，即该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。





​     1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；

​     2) 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；

​     3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。



- 结构体首地址 % 最宽基本类型成员的大小 = 0
- 成员偏移 % 成员大小 = 0
- 结构体总大小 % 结构体最宽基本类型成员大小 = 0



​     第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。

​     第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。

​     第三条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。



